_astavl_ = ACCEPT_ROOTED_TREES;
ACCEPT_ROOTED_TREES = 1;
Topology _ast_ = _TREE_STRING_FOR_PROCESSING_;
ACCEPT_ROOTED_TREES = _astavl_;

/* obtain an AVL data structure of the tree, post-order layout */

_astavl_ = _ast_^0;
_astavl_2 = _ast_^1;

/* Use the post-order layout of the tree to compute 

1). Sizes of subtrees rooted at every node 

*/

_tree_size_ = Abs (_astavl_);

is_binary = 1;

_sum_    	= 0;
_sum2_   	= 0;
_degree_ 	= 0;
_maxd_	 	= 0;
_cherries_  = 0;
_I_c_		= 0;
_B_2_		= 0;
_B_1_		= 0;

_beta_split = {_tree_size_/2-1,2};

for (_a_node = 1; _a_node < _tree_size_; _a_node = _a_node + 1)
{
	_node_info = _astavl_[_a_node];
	_a_parent = _node_info["Parent"];
	
	myDegree = Abs(_node_info["Children"]);
	myDepth  = _node_info["Maxd"];
	
	if (myDegree == 0)
	{
		_node_info["offspring"] = 1;
		_my_size  = 1;
		_astavl_[_a_node] = _node_info;
	}
	else
	{
		_my_size  = _node_info["offspring"];
			
		if (myDegree>2)
		{
			is_binary = 0;
		}
		
		if (_a_parent>0)
		{
			_B_1_ = _B_1_ + 1/_node_info["Maxd"];
		}
	}
	
	
	if (_a_parent > 0)
	{
		_node_info = _astavl_[_a_parent];
		_node_info["offspring"] = _node_info["offspring"]+_my_size;
		_node_info["Maxd"] = Max(_node_info["Maxd"],myDepth+1);
		_astavl_[_a_parent] = _node_info;
	}
}


_count_  	= 0;

if (is_binary)
{
	
	for (_a_node = 1; _a_node < _tree_size_; _a_node = _a_node + 1)
	{
		_node_info = _astavl_[_a_node];
		c1 = _node_info["Children"];
		myDegree = Abs(c1);

		if (myDegree == 2)
		{
			c2 = c1[1];
			c1 = c1[0];
			c1 = _astavl_[c1];
			c2 = _astavl_[c2];
			
			_beta_split [_count_][0] = _node_info["offspring"];
			_beta_split [_count_][1] = Min(c1["offspring"],c2["offspring"]);
			
			_count_ = _count_ + 1;
			
			_I_c_ = _I_c_ + Abs(c1["offspring"]-c2["offspring"]);			
		}
	}

	labels = {{"Parent Clade", "Smaller Daughter Clade"}};
	
	OpenWindow (CHARTWINDOW,{{"Splits in the tree"}
		{"labels"}
		{"_beta_split"}
		{"Scatterplot"}
		{labels[0]}
		{labels[1]}
		{"Size of parent"}
		{"LRT"}
		{"Size of daughter"}
		{""}
		{""}
		{""}
		{"10;1.309;0.785398"}
		{"Times:12:0;Times:10:0;Times:14:2"}
		{"0;0;16777215;5000268;0;0;6750054;11842740;13158600;14474460;0;3947580;16777215;0;5000268;11776947;10066329;9199669;7018159;1460610;16748822;11184810;14173291"}
		{"16"}
		},
		"(SCREEN_WIDTH-30)/2;(SCREEN_HEIGHT-50)/2;20+(SCREEN_WIDTH)/2;40");
}
else
{
	_I_c = 0/0;
}	

_count_  	= 0;

for (_a_node = 1; _a_node < _tree_size_; _a_node = _a_node + 1)
{
	_node_info  = _astavl_2[_a_node];
	_a_parent   = _node_info["Parent"];
	_pnode_info = _astavl_2[_a_parent];
	myDepth     = _pnode_info["Depth"]+1;
	_node_info["Depth"] = myDepth;
	c1 = _node_info["Children"];
	myDegree = Abs(c1);
	if (_a_parent)
	{
		_astavl_2[_a_node] = _node_info;
	}
	
	if (myDegree==0)
	{
		_count_ = _count_ + 1;
		_sum_   = _sum_   + myDepth;
		_B_2_   = _B_2_   + myDepth/2^myDepth;
		_sum2_  = _sum2_  + myDepth^2;
	}
	else
	{
		if (myDegree > _degree_)
		{
			_degree_ = myDegree;
		}

		if (myDegree == 2)
		{
			c2 = c1[1];
			c1 = c1[0];
			c1 = _astavl_2[c1];
			c2 = _astavl_2[c2];
			
			if (Abs(c1["Children"])+Abs(c2["Children"]) == 0)
			{
				_cherries_ = _cherries_ + 1;
			}
		}
	}
}

if (is_binary)
{
	is_binary = "         Yes";
}
else
{
	is_binary = "         No";
}


fprintf (stdout, "\nTOPOLOGY FEATURES\n",
				 "\nLeaves (tips)                    ", Format (_count_,10,0),
				 "\n(Internal) nodes                 ", Format (_tree_size_-_count_-1,10,0),
				 "\nIs binary?                       ", is_binary,
				 "\nMaximal degree                   ", Format (_degree_,10,0),
				 "\nNumber of Cherries               ", Format (_cherries_,10,0),
				 
				 "\n\nASSYMETRY STATISTICS\n",
				 "\nMean path to root (N bar)        ", Format (_sum_/_count_,10,4), 
				 "\nVar. path to root (sigma_N^2)    ", Format (_sum2_/_count_-(_sum_/_count_)^2,10,4), 
				 "\nColless Index (I_C)              ", Format (_I_c_*2/(_count_(_count_-3)+2),10,4), 
				 "\nShao and Sokal (B_1)             ", Format (_B_1_,10,4), 
				 "\nShannon entropy (B_2)            ", Format (_B_2_,10,4), 
"\n");
				 
				 
