MESSAGE_LOGGING = 0;

branchColors = {};

branchColors [0] = {{255,0,0}}*(1/255); 		/* red */
branchColors [3] = {{64,0,128}}*(1/255); 		/* eggplant */
branchColors [2] = {{0,0,0}};   	/* light gray */
branchColors [1] = {{0,128,0}}*(1/255);   		/* clover */

codonTo3 	= {};
codonOffset = 0;
AAString 	= "ACDEFGHIKLMNPQRSTVWY";


/*-----------------------------------------------------------------------------------------------*/

function setupMapToTree (dummy)
{
	ExecuteCommands ("DataSet ancestralSeqs  = ReconstructAncestors (`_chosenLFName`);GetString(lfInfo,`_chosenLFName`,-1);");
	
	treeCount = Columns (lfInfo["Trees"]);
	if (treeCount == 1)
	{
		treeID = (lfInfo["Trees"])[0];
		dfID   = (lfInfo["Datafilters"])[0];
	}	
	else /* decide which tree to work with */
	{
		choiceList = {treeCount,2};
		for (h=0; h<treeCount; h=h+1)
		{
			choiceList [h][0] = (lfInfo["Trees"])[h];
			choiceList [h][1] = "Use tree " + choiceList [h][0];
		}
		ChoiceList (treeID, "Select the tree to use for mapping", 1, SKIP_NONE, choiceList);
		if (treeID < 0)
		{
			return -1;
		}
		dfID   = (lfInfo["Datafilters"])[treeID];
		treeID = (lfInfo["Trees"])[treeID];
	}
	
	/* make a list of the sites to be included in the filter */
	ExecuteCommands ("theOO = `dfID`.site_map;");
	useSites = {};
	for (h=0; h<Columns(theOO); h=h+1)
	{
		useSites[theOO[h]] = 1;
	}
	
	
	fprintf (stdout, "[INFO] Using tree ", treeID, " on datafilter ", dfID, "\n");
	DataSetFilter	filteredDataA  = CreateFilter(ancestralSeqs,1,useSites[siteIndex]);
	ExecuteCommands ("HarvestFrequencies (observedCEFV,`dfID`,1,1,1);specCount = `dfID`.species; siteCount = `dfID`.sites; uSiteCount = `dfID`.unique_sites\n");

	ExecuteCommands ("branchNames  = BranchName (`treeID`,-1);");
	h 			 = Columns (branchNames);

	seqToBranchMap 	= {h, 2};
	/* maps sequence names to branch order in column 1 
	   and the other way around in column 2 */

	for (k=0; k<specCount; k=k+1)
	{	
		ExecuteCommands("GetString (seqName, `dfID`, k);");
		seqToBranchMap[k][0] = -1;
		for (v=0; v<h; v=v+1)
		{
			if (branchNames[v] % seqName)
			{
				seqToBranchMap[k][0] = v;
				seqToBranchMap[v][1] = k;
				break;
			}
		}
	}

	seqToBranchMap[specCount][0] = h-1;
	seqToBranchMap[h-1][1] = specCount;


	for (k=1; k<filteredDataA.species; k=k+1)
	{
		GetString (seqName, filteredDataA, k);
		seqToBranchMap[specCount+k][0] = -1;
		for (v=0; v<h; v=v+1)
		{
			if (branchNames[v] % seqName)
			{
				seqToBranchMap[k+specCount][0] = v;
				seqToBranchMap[v][1] = k+specCount;
				break;
			}
		}
	}

	ExecuteCommands ("GetDataInfo    (dupInfo, `dfID`);");
	GetDataInfo	    (dupInfoA, filteredDataA);
	
	stateCharCount	= 20;
	matrixTrick  	= {1,stateCharCount}["_MATRIX_ELEMENT_COLUMN_"];
	matrixTrick2 	= {1,stateCharCount}["1"];

	residueInfo  = {specCount, uSiteCount};
	residueInfo = {filteredDataA.species, filteredDataA.unique_sites};

	ExecuteCommands ("GetDataInfo    (dupInfo, `dfID`);");
	GetDataInfo	   (dupInfoA, filteredDataA);

	for (v=0; v<uSiteCount;v=v+1)
	{
		for (h=0; h<specCount;h=h+1)
		{
			ExecuteCommands("GetDataInfo (siteInfo, `dfID`, h, v);");
			_SITE_ES_COUNT = matrixTrick2 * siteInfo; 
			if (_SITE_ES_COUNT[0] == 1)
			{
				residueInfo[h][v] = (matrixTrick * siteInfo)[0];
			}
			else
			{
				residueInfo[h][v] = -1;
			}
		}
	}

	for (v=0; v<filteredDataA.unique_sites;v=v+1)
	{
		for (h=0; h<filteredDataA.species;h=h+1)
		{
			GetDataInfo (siteInfo, filteredDataA, h, v);
			residueInfo[h][v] = (matrixTrick * siteInfo)[0];
		}
	}

	ExecuteCommands ("flatTreeRep	  = Abs (`treeID`); GetInformation  (seqStrings, `dfID`);");
	return 0;
}
