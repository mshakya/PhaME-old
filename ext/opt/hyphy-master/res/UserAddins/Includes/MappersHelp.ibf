MESSAGE_LOGGING = 0;

branchColors = {};

branchColors [0] = {{255,0,0}}*(1/255); 		/* red */
branchColors [3] = {{64,0,128}}*(1/255); 		/* eggplant */
branchColors [2] = {{0,0,0}};   	/* light gray */
branchColors [1] = {{0,128,0}}*(1/255);   		/* clover */

codonTo3 = {};

codonOffset = 0;

codonTo3[0] = "F";
codonTo3[1] = "L";
codonTo3[2] = "I";
codonTo3[3] = "M";
codonTo3[4] = "V";
codonTo3[5] = "S";
codonTo3[6] = "P";
codonTo3[7] = "T";
codonTo3[8] = "A";
codonTo3[9] = "Y";
codonTo3[10] = "Stop";
codonTo3[11] = "H";
codonTo3[12] = "Q";
codonTo3[13] = "N";
codonTo3[14] = "K";
codonTo3[15] = "D";
codonTo3[16] = "E";
codonTo3[17] = "C";
codonTo3[18] = "W";
codonTo3[19] = "R";
codonTo3[20] = "G";

nucCharacters = "ACGT";

/*-----------------------------------------------------------------------------------------------*/

function codeToLetters (codonCode)
{
	return nucCharacters[codonCode$16]+nucCharacters[(codonCode%16)$4]+nucCharacters[codonCode%4];	
}

/*-----------------------------------------------------------------------------------------------*/

function setupMapToTree (dummy)
{
	ExecuteAFile 	(HYPHY_LIB_DIRECTORY+"TemplateBatchFiles"+DIRECTORY_SEPARATOR+"TemplateModels"+DIRECTORY_SEPARATOR+"chooseGeneticCode.def");
	ExecuteCommands ("DataSet ancestralSeqs  = ReconstructAncestors (`_chosenLFName`);GetString(lfInfo,`_chosenLFName`,-1);");
	
	treeCount = Columns (lfInfo["Trees"]);
	if (treeCount == 1)
	{
		treeID = (lfInfo["Trees"])[0];
		dfID   = (lfInfo["Datafilters"])[0];
	}	
	else /* decide which tree to work with */
	{
		choiceList = {treeCount,2};
		for (h=0; h<treeCount; h=h+1)
		{
			choiceList [h][0] = (lfInfo["Trees"])[h];
			choiceList [h][1] = "Use tree " + choiceList [h][0];
		}
		ChoiceList (treeID, "Select the tree to use for mapping", 1, SKIP_NONE, choiceList);
		if (treeID < 0)
		{
			return -1;
		}
		dfID   = (lfInfo["Datafilters"])[treeID];
		treeID = (lfInfo["Trees"])[treeID];
	}
	
	/* make a list of the sites to be included in the filter */
	ExecuteCommands ("theOO = `dfID`.site_map;");
	useSites = {};
	for (h=0; h<Columns(theOO); h=h+1)
	{
		useSites[theOO[h]] = 1;
	}
	
	
	fprintf (stdout, "[INFO] Using tree ", treeID, " on datafilter ", dfID, "\n");
	DataSetFilter	filteredDataA  = CreateFilter(ancestralSeqs,3,useSites[siteIndex],"",GeneticCodeExclusions);
	ExecuteCommands ("HarvestFrequencies (observedCEFV,`dfID`,3,3,0);specCount = `dfID`.species; siteCount = `dfID`.sites; uSiteCount = `dfID`.unique_sites\n");

	stateCharCount = 64;

	for (h=0; h<64; h=h+1)
	{
		if (_Genetic_Code[h] == 10)
		{
			stateCharCount = stateCharCount -1;
		}
	}
	
	ambChoice = 1;
	seqToBranchMap = {stateCharCount,1};

	hShift = 0;

	_GC_ 		= {stateCharCount,1};
	correctCode = {stateCharCount,1};

	for (k=0; k<64; k=k+1)
	{
		if (_Genetic_Code[k]==10)
		{
			hShift = hShift+1;
		}
		else
		{
			seqToBranchMap[k-hShift] = observedCEFV[k];
			_GC_[k-hShift]			 = _Genetic_Code[k];
			correctCode[k-hShift] 	 = k;
		}
	}

	observedCEFV = seqToBranchMap;
	ExecuteCommands ("branchNames  = BranchName (`treeID`,-1);");
	h 			 = Columns (branchNames);

	seqToBranchMap 	= {h, 2};
	/* maps sequence names to branch order in column 1 
	   and the other way around in column 2 */

	for (k=0; k<specCount; k=k+1)
	{	
		ExecuteCommands("GetString (seqName, `dfID`, k);");
		seqToBranchMap[k][0] = -1;
		for (v=0; v<h; v=v+1)
		{
			if (branchNames[v] % seqName)
			{
				seqToBranchMap[k][0] = v;
				seqToBranchMap[v][1] = k;
				break;
			}
		}
	}

	seqToBranchMap[specCount][0] = h-1;
	seqToBranchMap[h-1][1] = specCount;


	for (k=1; k<filteredDataA.species; k=k+1)
	{
		GetString (seqName, filteredDataA, k);
		seqToBranchMap[specCount+k][0] = -1;
		for (v=0; v<h; v=v+1)
		{
			if (branchNames[v] % seqName)
			{
				seqToBranchMap[k+specCount][0] = v;
				seqToBranchMap[v][1] = k+specCount;
				break;
			}
		}
	}

	ExecuteCommands ("GetDataInfo    (dupInfo, `dfID`);");
	GetDataInfo	    (dupInfoA, filteredDataA);

	matrixTrick  = {1,stateCharCount}["_MATRIX_ELEMENT_COLUMN_"];
	matrixTrick2 = {1,stateCharCount}["1"];

	codonInfo  = {specCount, uSiteCount};
	codonInfo2 = {filteredDataA.species, filteredDataA.unique_sites};

	ExecuteCommands ("GetDataInfo    (dupInfo, `dfID`);");
	GetDataInfo	   (dupInfoA, filteredDataA);

	for (v=0; v<uSiteCount;v=v+1)
	{
		for (h=0; h<specCount;h=h+1)
		{
			ExecuteCommands("GetDataInfo (siteInfo, `dfID`, h, v);");
			_SITE_ES_COUNT = matrixTrick2 * siteInfo; 
			if (_SITE_ES_COUNT[0] == 1)
			{
				codonInfo[h][v] = (matrixTrick * siteInfo)[0];
			}
			else
			{
				codonInfo[h][v] = -1;
			}
		}
	}

	for (v=0; v<filteredDataA.unique_sites;v=v+1)
	{
		for (h=0; h<filteredDataA.species;h=h+1)
		{
			GetDataInfo (siteInfo, filteredDataA, h, v);
			codonInfo2[h][v] = (matrixTrick * siteInfo)[0];
		}
	}

	ExecuteCommands ("flatTreeRep	  = Abs (`treeID`); GetInformation  (seqStrings, `dfID`);");
	return 0;
}
